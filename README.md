# myMovieTracker

technicalDetails:

I developed the entire app, including both the front-end and back-end, as well as the complete state management. It’s a fully custom-built project that allows me to track the movies I watch and monitor my viewing history. The application is still a work in progress, and this is just the first, more basic version. It's a movie tracking app where users can write reviews, view detailed information about movies, talk to a bot and ask him anything related to movies, and many more features. The app is designed to help users manage their movie preferences and stay updated on the latest films they've watched or want to watch.

    ===================================================================================================================
                                                       Backend

nodeBackend:

Honestly, once I had the entire backend set up, things became much easier. The biggest challenge was definitely getting everything off the ground especially with setting up authentication, the database, and middlewares. But once that foundation was in place, everything else started to fall into place and became much more manageable. The backend runs on Node.js and Express, offering a REST API to handle requests. Data is stored in PostgreSQL, which provides a reliable and scalable solution for managing user information, and movie data. For authentication, I implemented JSON Web Tokens (JWT) paired with bcrypt for secure password hashing.

pythonBackend:

I felt that I needed some innovation in the app, so I decided to use Python and try to create different features. I chose Python because it gives me more possibilities than NodeJS.

Chat Assistant Functionality

This is a Movie Chat Assistant that leverages the Groq API for processing user queries. The chat assistant uses the Llama3-70B-8192 model, a highly efficient language model that provides faster responses compared to other models like chatGPT, offering significantly reduced latency.

ReccomenendMovies

This function provides movie recommendations based on a user's selected movie. It calculates the similarity between movies using their overviews and genres. When the movie_id is submitted, the app recommends 8 similar movies by analyzing their synopses and genres. It leverages machine learning techniques like TF-IDF for text vectorization and cosine similarity for comparing movie features, creating a personalized recommendation system.

Graph (voteCount and voteAverage)

I made a function that creates a graph showing how a movie's Vote Average and Vote Count change over time. It takes the movieId from the frontend, then pulls the data from the database (like the date, vote average, and vote count). After that, it creates a graph with two lines: one showing the vote average and the other showing the vote count.
The graph is made using Matplotlib and saved as a PNG image. This image is then sent to the frontend and displayed with the movie’s movieId.

Then I ended up doing the same thing for the movies watched by the users in the last months. I created a function that shows the progress in a one-axis line.

generateFakeIMDB

The fucntion generates a "fakeIMDB" score by combining the movie's rating and sentiment analysis of the reviews. It uses VADER to analyze the review content and also takes into account the user-provided rating. The "fake IMDb" score is calculated based on both factors and stored in the database.

    ===================================================================================================================

Frontend:

The frontend was developed using React and TypeScript, ensuring a dynamic and type-safe user experience. Zustand is used for state management, making the data flow more efficient. For styling, I used Bootstrap, enabling fast and easy design implementation. The app is populated with fake data generated by the Faker library, and for the database, I used The Movie Database (TMDB) API. The app is deployed on Render and Vercel for smooth and fast hosting. I also integrated the Framer Motion library for animations, used Lazy Loading to optimize performance, and implemented React Router for smooth and scalable routing.
